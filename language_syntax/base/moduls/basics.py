# Файл с исходными текстами модуля автоматически превращается в объ-
# ект модуля в результате выполнения операции импортирования. С техни-
# ческой точки зрения исходный программный код модуля выполняется во
# время импортирования, инструкция за инструкцией, и все имена, которым
# по мере выполнения операций будут присвоены значения, превращаются
# в атрибуты объекта модуля.

# питон ищет модули так:
# 1) домашний каталог с текущим питон файлом (откуда запустил прогу)
# 2) env variable - PYTHONPATH
# 3) standart library
# 4) .pth файл в папке с установленном питоном. там список файлов для импорта

# Из всего вышесказанного следует, что переменная окружения PYTHONPATH
# и файлы .pth позволяют вам определять каталоги, где интерпретатор будет искать файлы
# при выполнении операции импортирования.

# Например, в Windows можно воспользоваться ярлыком Система (System) в панели управления,
# чтобы записать в переменную PYTHONPATH список каталогов, разделенных точкой с запятой, как показано ниже:
# c:\pycode\utilities;d:\pycode\package1

# Или создать текстовый файл с именем C:\Python30\pydirs.pth, который выглядит примерно так:
# c:\pycode\utilities
# d:\pycode\package1

# sys.path - список строк с именами каталогов представляет собой фактический путь поиска, используемый интерпретатором;
#          - список строк с именами каталогов, которые просматриваются интерпретатором при импортировании новых файлов.

import sys

for i in sys.path:
    print(i)

print('=' * 100)


# Инструкция from импортирует модуль целиком, как и инструкция import, но кроме этого она еще копирует
# одно или более имен из импортируемого модуля В ТУ ОБЛАСТЬ ВИДИМОСТИ, ГДЕ НАХОДИТСЯ ИНСТРУКЦИЯ FROM.
# Это позволяет использовать импортированные имена напрямую (name), без дополнения их именем модуля (module.name).
# Кроме того, подобно инструкции def, import и from – это явные операции присваивания!


from language_syntax.base.moduls.hi_friend import x, y # Скопировать имя x и y, также видим что выполнился
# модуль hi_friend, а также файлы инит каждого пакета, в них формируется неймспейс каждого пакета
# from .hi_friend import x, y # можно использовать импорт относительно пакета moduls

print(x)
x = 42 # локальной x переопределяем скопированный x из модуля hi_friend
print(x, y)
y[0] = 100 # ИЗМЕНИТЬ y в другом модуле

print('=' * 100)


import hi_friend # Получить имя модуляь, присвоить переменной hi_friend объект модуля
print(hi_friend)
hi_friend.x = 35
print(x, y, hi_friend.x, hi_friend.sys)

print(hi_friend.__dict__.keys())  # __name__ - имя импортированного файла без .py (в моём случае hi_friend)
                                  # для текущего модуля basics __name__ равен main

from importlib import reload

print(reload(hi_friend).__dict__['x'])
print('=' * 100)

import language_syntax.base.moduls
# Каждый каталог в пути фактически становится переменной, которой присваивается объект модуля,
# пространство имен которого инициализируется всеми инструкциями присваивания в файле __init__.py
print(language_syntax.__dict__.keys())
