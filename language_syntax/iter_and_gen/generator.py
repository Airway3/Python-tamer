"""
Генераторы – это объекты, поддерживающие итерационный протокол, они обладают методом __next__, который выполняет переход к следующе-
му элементу в последовательности результатов и возбуждает исключение по достижении конца последовательности. В языке Python существует
возможность создавать функции-генераторы с помощью инструкции def, выражения-генераторы в виде генераторов списков, заключенных в кру-
глые скобки, и объекты-генераторы с помощью классов, которые определяют специальный метод __iter__.
"""

my_gen_obj = (i*3 for i in range(4)) # выражение генератор
print(my_gen_obj, list(my_gen_obj)) # в отличии от лист компрехеншена выражение в круглых скобках не вернёт нам готовый список

'''
Так что же такое генераторное выражение и что такое вообще генератор?
Если простым языком, генераторное выражение — это еще один синтаксический сахар в Python, простейший способ создать объект
с интерфейсом итератора, при этом не загружая всех элементов в память (а это чаще всего и не нужно).

Вот, скажем, про функции в языке обычно не знает только тот, кому первую книжку по программированию подарили сегодня.
Если вчера — уже, скорее всего, знает. Но у функций строго определенное поведение — у них одна точка входа и одно возвращаемое значение
(то, что в Python можно делать «return a, b», — это не множественный возврат в полном смысле этого слова. Это всего лишь возврат кортежа).
А что, если я скажу, что генератор — это та же функция, только с несколькими точками входа и выхода?

Основная фишка генератора в том, что он, подобно итератору, запоминает последний момент, когда к нему обращались, но при этом оперирует
не абстрактными элементами, а вполне конкретными блоками кода. То есть если итератор по умолчанию будет перебирать элементы в контейнере,
пока они не кончатся, то генератор будет гонять код, пока не выполнится какое-нибудь конкретное условие возврата.
'''


# генератор функция
def my_generator():
    with open('test-open-file.txt') as f:
        for l in f:
            if 'shit' in l:
                yield l


myiterator = my_generator()
for item in myiterator:
    print(item)

'''
При наличии этой инструкции интерпретатор Python компилирует функцию как генератор – при вызове она возвращает объект-генератор, который
поддерживает итерационный протокол. Когда запускается инструкция yield, она возвращает результат вызывающей программе и приостанавли-
вает работу функции, после этого, в ответ на вызов встроенной функции next или метода __next__ со стороны вызывающей программы, функция воз-
обновляет свою работу с позиции после последней выполненной инструкции yield. Функции-генераторы также могут содержать инструкцию return,
которая завершает работу генератора.

Ключевое слово yield служит как раз разделителем блоков кода, которые исполняет генератор на каждом обращении к нему,
то есть на каждой итерации. Собственно, цикл вовсе не обязателен, можно просто написать несколько кусков кода в функции и разделить
их оператором yield. Интерфейс все равно останется точнехонько тот же, итераторный.
'''
