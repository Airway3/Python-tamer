'''
Вызов методов при доступе к атрибуту.
Дескрипторы атрибутов (далее просто дескрипторы) описывают протокол (правила) доступа к атрибутам объекта, или класса.
В общем случае дескрипторы — это объекты, в которых определен один из методов: __get__(), __set__(), или __delete__().
Среди уже определенных в Python дескрипторов можно назвать следующие: property, classmethod и staticmethod.
Рассмотрим интерфейс дескрипторов на примере.

Возможности property достаточно ограничены, тогда как дескрипторы позволяют получить более общее решение.
Методы дескрипторов, управляющие доступом, получают аргумент self со ссылкой на сам дескриптор и экземпляр клиентского класса.
Благодаря этому они могут сохранять и использовать собственные данные, а также данные объекта экземпляра.
Например, дескриптор может вызывать не только методы клиентского класса, но и собственные методы, определенные в классе дескриптора.

ГЛАВНОЕ ПРЕИМУЩЕСТВО ДЕСКРИПТОРА ОТ PROPERTY - благодаря тому, что дескрипторы могут работать с собственными
данными, они легко могут сохранять данные внутри себя, не засоряя пространство имен клиентского объекта экземпляра.
'''


class TestDescriptor(object):
    '''
    self - экземпляр класса дескриптора
    obj/instance - экземпляр класса которому присвоен экземпляр дескриптора
    type/owner - класс которому присвоен экземпляр дескриптора

    '''

    def __get__(self, obj, type=None):
        print("__get__(%r, %r)" % (obj, type))
        return "value"

    def __set__(self, obj, value):  # отсутствие этого метода позволяет переопределить атрибут в классе хозяине

        '''
        чтобы сделать атрибут доступным только для чтения, необходимо определить метод __set__,
        который  будет  перехватывать  операции  присваивания и возбуждать исключение (чтобы не переопределить атрибут с дескриптором).
        def __set__(self, instance, value):
            raise AttributeError(“can’t set attribute”)
        '''
        print("__set__(%r, %r)" % (obj, value))

    def __delete__(self, obj):
        print("__delete__(%r)" % obj)


class Test_desc(object):
    attribute = TestDescriptor()

'''
Для объектов (class instance) алгоритм реализуется с помощью object.__getattribute__, который преобразует
запись b.x в type(b).__dict__['x'].__get__(b, type(b)). Реализация работает через цепочку предшественников, в
которой дескрипторы данных имеют приоритет перед переменными объекта, переменные объекта имеют приоритет перед дескрипторами
не данных (only __get__), и самый низкий приоритет у метода __getattr__, если он определён.

Для классов алгоритм реализуется с помощью type.__getattribute__, который преобразует
запись B.x в B.__dict__['x'].__get__(None, B).

Важные части, которые следует запомнить:

    дескрипторы вызываются с помощью метода __getattribute__
    переопределение __getattribute__ прекратит автоматический вызов дескрипторов
    __getattribute__ доступен только внутри классов и объектов нового стиля
    object.__getattribute__ и type.__getattribute__ делают разные вызовы к __get__
    дескрипторы данных всегда имеют преимущество перед переменными объекта
    дескрипторы не данных могут потерять преимущество из-за переменных объекта

'''
print(Test_desc.attribute)
t = Test_desc()
print(t.attribute)
t.attribute = "new value"
print(t.attribute)  # если закоментить set то атрибут класса заменит дескриптор на что-то другое
del t.attribute


'''
Надо также заметить, что дескрипторы вызываются из метода __getattribute__() определенного в классе object
и его переопределение может отменить автоматическое обращение к дескрипторам при доступе к атрибутам.
'''


# class Descr(object):
#
#     def __get__(self, instance, owner): # ссыль на экз владельца дискриптора и его класс
#         print(repr(instance), repr(owner)) # instance = None, если обращение к атрибуту выполняется непосредственно через имя клиентского класса
#         return None
#
#     def __set__(self, instance, value): # ссыль на экз владельца дискриптора и новое знач
#         print(repr(instance), repr(value)) # ничего не должна возвращать (ноне)
#         return None
#
#     def __delete__(self, instance): # удаляется атрибут, сработает когда у экз применим инструкцию del
#         print('Deleted!') # ничего не должна возвращать (ноне)
#
# class C(object):
#     d = Descr()
#
# print('------------------------------------------------------')
#
# C.d # get через класс
# C().d # get через экз
#
# print('------------------------------------------------------')
#
# del C().d
# c_inst = C()
# del c_inst.d
# c_inst.d = 123
#
# C.d = 235 # в атрибут d присвоили число, дескриптор удалился
# print(C.d, type(C.d)) # нужно понимать что сеттер имеет смысл только для экземпляра класса владельца дескриптора
#
#
# class CachedProperty(object):
#     def __init__(self, getter):
#         self._g = getter
#     def __get__(self, instance, owner):
#         try:
#             result = getattr(instance, '_cached')
#         except AttributeError:
#             result = self._g(instance)
#             setattr(instance, '_chached', result)
#         return result
#
# class Cp(object):
#     @CachedProperty
#     def calc(self):
#         print('calculating........')
#         return 42
#
# cp = Cp()
# print(cp.calc)
# print(cp.calc)
