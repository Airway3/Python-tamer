'''
Так что же такое генераторное выражение и что такое вообще генератор?
Если простым языком, генераторное выражение — это еще один синтаксический сахар в Python, простейший способ создать объект
с интерфейсом итератора, при этом не загружая всех элементов в память (а это чаще всего и не нужно). А что до генератора как концепции…

Вот, скажем, про функции в языке обычно не знает только тот, кому первую книжку по программированию подарили сегодня.
Если вчера — уже, скорее всего, знает. Но у функций строго определенное поведение — у них одна точка входа и одно возвращаемое значение
(то, что в Python можно делать «return a, b», — это не множественный возврат в полном смысле этого слова. Это всего лишь возврат кортежа).
А что, если я скажу, что генератор — это та же функция, только с несколькими точками входа и выхода?

Основная фишка генератора в том, что он, подобно итератору, запоминает последний момент, когда к нему обращались, но при этом оперирует
не абстрактными элементами, а вполне конкретными блоками кода. То есть если итератор по умолчанию будет перебирать элементы в контейнере,
пока они не кончатся, то генератор будет гонять код, пока не выполнится какое-нибудь конкретное условие возврата.
Да-да, по большому счету предоставленный в первом разделе код — это генератор с интерфейсом итератора, у которого есть вполне определенное
условие выхода. Если развернуть генераторное выражение из кода выше в полноценную функцию-генератор, получится примерно так:
'''
def my_generator():
    with open('test-open-file.txt') as f:
        for l in f:
            if 'shit' in l:
                yield l
myiterator = my_generator()
for item in myiterator:
    print(item)

'''
Ключевое слово yield служит как раз разделителем блоков кода, которые исполняет генератор на каждом обращении к нему,
то есть на каждой итерации. Собственно, цикл вовсе не обязателен, можно просто написать несколько кусков кода в функции и разделить
их оператором yield. Интерфейс все равно останется точнехонько тот же, итераторный.
'''